# Java

## ****자바 프로그램의 실행 과정****

우선, 자바 컴파일러가 소스 코드를 바이트 코드로 변환하여 .class 파일을 생성합니다. 자바 가상 머신은 이 클래스 파일을 읽어들여 바이트 코드를 바이너리 코드로 변환하며 프로그램을 실행합니다.

## 자바 가상 머신의 역할

자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것입니다.

## 자바 가상 머신의 동작 방식

자바 컴파일러가 소스코드를 바이트 코드로 변환하여 클래스 파일을 생성합니다
JVM의 클래스로더는 동적 로딩을 통해 필요한 클래스들을 로드 및 링킹하여 Runtime Data Area에 올리게 됩니다.
이 Runtime Data Area에 적재된 바이트 코드를 실행 엔진이 읽어들여 해석하게 됩니다.
이 과정에서 실행 엔진에 의해 가비지 컬렉션과 쓰레드 동기화가 이루어집니다.

## ****자바 가상 머신(JVM)의 구조****

- JVM은 크게 클래스 로더, 런타임 데이터 영역, 실행 엔진으로 구성됩니다.
- **클래스 로더**
    - 클래스 로더는 바이트 코드인 클래스 파일을 동적으로 로드하고 링크하여 JVM의 메모리 영역인 런타임 데이터 영역에 배치합니다.
    - 클래스 파일의 로딩 과정은 크게 3가지로 나뉩니다
        - 로딩
            - 클래스 파일을 읽어들여 JVM의 메모리에 로드하는 과정
        - 링킹
            - 클래스 파일을 사용하기 전에 검증하는 과정
            - Verifying : 클래스 파일이 JVM의 명세를 따르는지 검사하는 과정입니다
            - Preparing : 클래스가 필요하는 메모리를 할당하는 과정
            - Resolving : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
        - 초기화 : 클래스 변수들을 적절한 값으로 초기화한다.
- **실행 엔진**
    - 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행하는 역할을 수행합니다.
    - 이 과정에서 실행 엔진은 **인터프러티 방식**과 **JIT 컴파일러 방식**을 혼합하여 바이트 코드를 실행합니다
    - **인터프리터 방식**
        - 자바 인터프리터가 바이트 코드 명령어를 하나씩 읽고 해석하여 실행하는 방식입니다.
        - JVM안에서 바이트코드는 기본적으로 인터프리터 방식으로 동작한다.
        - 단점으로는 같은 코드를 여러번 실행해도 매번 해석을 해야되기 때문에 실행 속도가 느리다는 점입니다.
    - **JIT 컴파일러 방식**
        - 자주 반복되는 코드를 native code로 컴파일하여, 매번 인터프리팅하는 대신 native code로 직접 실행하는 방식
            - native code : 자바의
    - Garbage Collector
        - Heap 영역에서 사용되지 않는 메모리를 자동으로 회수합니다.
- **런타임 데이터 영역**
    - JVM의 메모리 영역으로, 자바 애플리케이션 실행시 필요한 데이터들을 적재하는 영역입니다.
    - 런타임 데이터 영역은 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 나뉩니다.
    - **Method** **영역**
        - 자바 가상 머신 실행시 생성되어 종료될 때 까지 유지되는 공간으로, 모든 쓰레드가 공유하는 영역입니다.
        - 메서드 영역에는 각 클래스 및 인터페이스에 대한 정보가 저장됩니다.
            - 저장되는 정보로는 필드, 메서드, 타입, 런타입 상수 풀에 대한 정보가 있습니다.
        - **런타임 상수 풀**은 각 클래스 혹은 인터페이스마다 가지고 있는 상수 풀 테이블을 저장하는 공간으로, JVM은 이 상수 풀을 사용해 메서드나 필드의 실제 메모리 주소를 찾아 참조합니다.
    - **Heap 영역**
        - 런타임 시 동적으로 할당하여 사용하는 메모리 영역으로, **레퍼런스 타입의 데이터를 저장하는 공간**입니다.
        - 이러한 힙 영역은 가비지 컬렉션을 효율적으로 수행하기 위해 Young Generation과 Old Generation 영역으로 나뉩니다.
            - **Young Generation** : Minor GC가 수행되는 영역입니다.
                - Eden : new 키워드를 통해 새로 생성된 객체가 저장되는 영역입니다.
                - **Survivor 0, 1**
                    - Garbage Collection에서 살아남은 Eden영역의 객체들이 이동하는 공간입니다.
                    - Survivor 영역의 특이한 규칙으로는 매 순간 Survivor 0과 Survivor1 둘중에 하나는 비어있어야 한다는 점입니다.
            - **Old Generation** : Young Generation에서 살아남은 객체가 이동하는 영역으로, 생명주기가 긴 객체를 GC 대상으로 하는 영역
                - Old :
                - Permanent :
    - **Stack 영역**
        - 메서드 호출 시 생성되는 스택 프레임이 저장되는 공간입니다. 스택 프레임에는 메서드의 매개변수, 지역변수, 리턴 값 등 임시적인 정보가 저장됩니다. 이러한 스택 프레임은 메서드 호출 영역을 벗어나면 메모리에서 해제됩니다.
        - 지역 변수 중 원시 타입 변수는 스택 영역에 직접 값을 가지고, 참조 타입 변수는 메서드나 힙 영역의 객체 주소를 가집니다.
    - **PC 레지스터 영역**
        - 쓰레드 별로 생성되는 영역으로, **현재 실행중인 JVM 명령어의 주소를 저장하는 공간**입니다.
        - 
    - **네이티브 메서드 스택 영역**
        - 자바 이외의 언어로 작성된 네이티브 코드를 실행하기 위한 공간입니다.
        - 메서드를 실행하던 도중 네이티브 메서드를 만나면, 해당 메서드의 스택 프레임은 스택 영역이 아닌 네이티브 메서드 스택 영역에 쌓입니다. 네이티브 메서드의 수행이 끝나며 다시 자바 스택으로 돌아와서 작업을 수행하는 방식으로 동작합니다.
        - **JNI**는 자바가 다른 언어로 만들어진 어플리케이션과 상호작용할 수 있는 인터페이스입니다. 자바 네이티브 인터페이스를 통해 네이티브 메서드를 JVM에 로드하여 실행할 수 있습니다.
        - Native Method Library : C, C++로 작성된 라이브러리를 의미합니다.

## GC

- 자바의 메모리 관리 방법 중의 하나로 JVM(자바 가상 머신)의 **Heap 영역**에서 **동적으로 할당했던 메모리** 중 **필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거**하는 프로세스
- 장점
    - 가비지 컬렉터가 개발자 대신 메모리를 자동으로 관리해주기 때문에, 메모리 누수 문제를 신경쓰지 않고 개발에만 집중할 수 있다는 장점이 있습니다.
- 단점
    - 가비지 컬렉션 수행 시, GC 관련 쓰레드 이외에 모든 쓰레드가 중단되는 Stop-The-World 문제가 발생합니다.
    - 또한, 가비지 컬렉션의 수행 시기를 정확하게 알 수가 없어 제어가 어렵다는 단점이 있습니다.
- 가비지 컬렉션 대상
    - 가바지 컬렉터는 객체가 가비지 컬렉션의 대상인지 아닌지를 판단하기 위해 객체의 Reachability를 판단합니다. 어떤 객체에 대한 참조가 존재하면 reachable로 구분하고, 존재하지 않으면 unreachable로 구분하는데, 이러한 unreachable 객체가 바로 Garbage Collection의 대상이 됩니다.
- 가비지 컬렉션의 동작 방식
    - Mark, Sweep, Compaction 과정으로 나뉩니다.
    - Mark 과정에서는 Root Space로부터 그래프를 순회하여 각 객체가 어떤 객체들을 참고하고 있는지 마킹합니다.
    - Sweep 과정에서는 마킹되어 있지 않은 unreachable 객체를 heap 영역에서 제거합니다
    - Compaction 과정에서는 sweep후 분산된 객체들을 heap의 시작주소로 모아 compaction을 수행합니다. 이러한 compaction을 통해 external fragmentation을 해결합니다.
- Minor GC
    - Young Generation에서 수행되는 가비지 컬렉션입니다.
    - 객체가 생성되어 Eden 영역이 꽉 차게되면, Minor GC가 수행됩니다.
    - Marking 과정을 통해 Reachable로 판단된 객체는 비어있는 Survivor 영역으로 이동하고 age값이 1 증가합니다. 그리고 Unreachable로 판단된 객체는 Young Generation에서 제거됩니다.
    - 객체의 Age값이 임계치를 넘어서면 Old Generation으로 이동하게 됩니다.
- Major GC
    - Old Generation에서 수행되는 가비지 컬렉션입니다.
    - Major GC는 객체들이 계속 Promotion되어 Old영역이 가득차게 되면 수행됩니다.
    - Major GC도 Minor GC와 마찬가지로 Mark, Sweep, Compaction 과정을 수행합니다.
    - Major GC의 경우 Old 영역의 크기가 크기 때문에 Minor GC보다 Garbage Collection에 오랜 시간이 소요됩니다. 이때 발생하는 문제가 Stop-The-World 문제입니다. Stop-The-World는 GC 과정에서 GC와 관련된 쓰레드 외의 모든 쓰레드가 중단되면서 애플리케이션이 지연되는 현상입니다.
- Serial GC
    - 서버의 CPU 코어가 1개일 때 사용하기 위한 단순한 GC
    - GC를 처리하는 쓰레드가 1개 (싱글 쓰레드) 이어서 가장 stop-the-world 시간이 길다
    - Minor GC 에는 Mark-Sweep을 사용하고, Major GC에는 Mark-Sweep-Compact를 사용한다.
- Parallel GC
    - Java 8의 디폴트 GC
    - Serial GC와 기본적인 알고리즘은 같지만, Minor GC를 멀티 쓰레드로 수행 (Old 영역은 여전히 싱글 쓰레드)
    - Serial GC에 비해 stop-the-world 시간 감소
    - 기본적으로 CPU 코어의 개수만큼 GC 쓰레드를 할당합니다
- Parallel Old GC
    - Parallel GC를 개선한 버전으로, Young 영역 뿐만 아니라, Old 영역에서도 멀티 쓰레드로 GC 수행
    - 또한, Mark-Summary-Compact 라는 새로운 방식으로 가비지 컬렉션을 진행합니다
- G1 GC

---

## ****Java의 특징****

- Java는 객체지향 프로그래밍 언어입니다. 원시 자료형을 제외한 모든 요소들이 객체로 표현되며, 객체 지향 특징인 캡슐화, 상속, 추상화, 다형성이 잘 적용된 언어입니다.
- Java의 장점
    - 자바 가상 머신을 사용함으로써 One Write Read Anywhere가 가능하다는 것입니다. 즉, 한번 작성한 소스코드 혹은 클래스 파일을 운영체제 종류와 상관없이 JVM이 설치된 어느 기기에서도 실행이 가능하다는 것입니다.
    - 또한, JVM이 제공하는 가비지 컬렉션을 통해 메모리가 자동으로 관리되면서 개발자로부터 메모리 관리의 부담을 덜어준다는 장점이 있습니다.
- Java의 단점
    - 반면 단점으로는, 다른 프로그래밍 언어와 달리 운영체제 상위에 자바 가상 머신을 통해 프로그램이 실행되기 때문에 실행 속도가 느리다는 단점이 있습니다.
    - 또한, 다중 상속이 불가능하고 강타입 언어이기 때문에 type checking을 진행하는 등 프로그래밍에 있어 제약사항이 많은 편입니다.
- 자바는 JIT Compiler를 통해 코드를 캐싱함으로써 동적 번역을 수행합니다. 이러한 방식은, 이전 방식인 자바 인터프리터 방식에 비해 10배 이상의 개선된 성능을 보입니다.

## 자바의 컴파일 과정

- 개발자가 작성한 자바 소스코드를 JDK의 javac 라는 자바 컴파일러를 통해 바이트 코드로 변환하여 클래스 파일을 생성합니다. 이 클래스파일을 JVM의 클래스 로더가 읽어들여 JVM의 런타임 데이터 영역으로 로드 및 링킹을 수행합니다. 이렇게 JVM 메모리에 로드된 바이트 코드를 JVM의 실행 엔진이 자바 인터프리터와 JIT 컴파일러를 사용하여 이진 코드로 변환하면서 프로그램을 실행하게 됩니다.

## 자바의 원시타입에는 무엇이 있고 각각의 크기는 어떻게 되나요?

- 자바에서 제공하는 원시 타입에는 정수형, 실수형, 논리형, 문자형이 있습니다.
- 정수형 원시타입에는 byte, short, int, long이 있으며 각각 1, 2, 4, 8바이트를 차지합니다.
- 실수형 원시타입에는 float과 double이 있으며, 각각 4, 8바이트를 차지합니다.
- 논리형 원시타입에는 boolean이 있으며, 1 바이트를 차지합니다.
- 문자형 원시타입에는 char이 있으며, 2바이트를 차지합니다.
- 이 중 정수형의 경우 마이너스와 플러스값을 지니지만, 논리형의 경우 true와 false만을 지원하고, char의 경우 0~65535까지의 범위를 가짐으로써 음수를 지원하지 않습니다.
    - char 자료형의 경우 16비트 유니코드 문자를 나타내기 위해 사용하는 자료형입니다. 16비트 유니코드가 양수의 값만을 가지기 때문에, 이러한 유니코드와의 호환성을 위해 값의 범위를 제한했습니다.

## 오버라이딩과 오버로딩에 대해 설명해주세요

- 오버라이딩은 상위 클래스의 메서드를 하위 클래스에서 재정의 하는 것을 말하고, 오버로딩은 메서드의 시그니처를 달리하여 같은 이름의 메서드를 여러개 정의하는 것을 말합니다.
- 자바는 오버리이딩을 통해 객체지향의 특성인 다형성을 구현하였습니다. 이를 통해, 객체의 실제 타입에 따라 다른 동작이 수행됨으로써 코드의 유연성과 가독성이 증가합니다.
- 오버로딩도 시그니처가 달라질 때 마다 새로운 이름의 메서드를 정의하지 않고 기존 메서드의 이름을 재사용할 수 있기 때문에 코드의 유연성과 가독성이 증가합니다.

## try-with-resources에 대해 설명해주세요

- try with resources는 java 7버전에 새로 추가된 구문으로, try 문에 자원객체를 전달하면 try 블록을 벗어날 때 자원을 해제해주는 기능입니다. 여기서 try문에 전달할 수 있는 자원으로는 AutoCloseable 인터페이스의 구현체로 한정됩니다. 이러한 기능을 통해 try catch finally 구문에서 반복적으로 수행되는 자원 할당 코드를 생략함으로써 가독성이 증가한다는 장점이 있습니다. (+ 메모리 누수 방지?)

## 가비지 컬렉션에 대해 설명해주세요

가비지 컬렉션은 자바 가상 머신의 메모리 관리 기법으로, 힙 영역에서 사용되지 않는 객체를 자동으로 회수하여 메모리를 관리해주는 기법입니다.

- 가비지 컬렉션의 과정에 대해 설명해주세요
    
    가비지 컬렉션은 힙의 영역에 따라 다르게 수행됩니다. 자바 가상 머신의 힙 메모리의 경우 Young Generation과 Old Generation으로 나뉩니다.
    Young Genereation의 경우 Minor GC가 수행되고, Old Generation에서는 Major GC가 수행됩니다.
    Minor GC의 경우 Young Generation의 Eden 영역이 가득찬 경우 수행됩니다.
    우선 Mark과정을 통해 young generation의 객체들이 실제로 참조되고 있는지를 확인하여 reachability를 판단합니다.
    
    Sweep 과정에서는 다른 객체로부터 참조되고 있는 reachable 객체의 경우 age값이 1 증가되며, survivor 0과 1 영역 중 비어있는 영역으로 이동하게 됩니다. age값이 특정 임계치를 넘어서면 Old Generation의 Old 영역으로 이동합니다. 다른 객체로부터 참조되고 있지 않은 Unreachable 객체의 경우 메모리에서 제거됩니다.
    
    Compact 과정에서는 Sweep 과정에서 살아남은 Reachable 객체를 Young Generation의 각 영역의 시작부분으로 이동함으로써 외부 단편화를 해결합니다.
    
    Major GC의 경우 Old Generation에서 수행되는 가비지 컬렉션으로, 동작 방식은 가비지 컬렉션 알고리즘에 따라 다르긴
    

## **객체지향의 설계원칙에 대해 설명해주세요.**

1. **SRP** - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
2. **OCP** - 개방-폐쇄 원칙 : 확장에는 열려있고, 수정에는 닫혀있어야 한다.
3. **LSP** - 리스코프 치환 원칙 : 하위 타입은 항상 상위 타입을 대체 할 수 있어야 한다.
4. **ISP** - 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한 일수록 좋다. (하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.)
    
    SRP와 같은 문제에 대한 두 가지 다른 해결책이다.
    
5. **DIP** - 의존관계 역전 원칙 : 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라.
    
    DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다
    

## 자바의 메모리 영역에 대해 설명해주세요

- 자바의 메모리 영역은 크게 메서드 영역, 힙 영역, 스택 영역, 네이티브 메서드 스택 영역, PC 레지스터 영역으로 나뉩니다. 이 중 메서드 영역과 힙 영역은 프로세스의 모든 쓰레드들이 공유하는 영역이며, 나머지 영역은 각 쓰레드별로 생성되어 개별적으로 사용하는 공간입니다.
- 메서드 영역에는 프로그램에서 사용되는 클래스와 인터페이스에 대한 정보가 저장됩니다. 저장되는 정보로는 타입, 메서드, 필드 정보, 전역변수, 스태틱변수, 런타임 상수 풀이 있습니다.
- 힙 영역은 런타임 시 동적으로 할당되는 메모리 영역으로, 레퍼런스 타입의 데이터를 저장하는 공간입니다. 이러한 힙 영역은 가비지 컬렉션을 통해 자동으로 관리됩니다. 가비지 컬렉션의 효율성을 높이기 위해 힙 영역은 Young Generation과 Old Generation으로 나뉘며, Young Generation은 다시 Eden, Survivor 0, Survivor 1 영역으로 나뉩니다.
- 스택 영역은 메서드 호출 시 생성되는 스택 프레임의 저장 공간으로, 메서드에서 사용되는 임시 정보들이 저장됩니다. 저장되는 정보로는 매개변수, 지역변수, 리턴값 등이 있습니다. 이러한 스택프레임은 해당 메서드 영역을 벗어나면 자동으로 삭제됩니다.
- 네이티브 메서드 스택 영역은 자바 이외의 언어로 작성된 네이티브 메서드를 실행하기 위한 공간입니다. Java Native Interface를 통해 Native Method를 JVM의 네이티브 메서드 스택 영역으로 로드하여 실행합니다.
- PC Register 영역은 현재 실행중인 JVM 명령어의 주소를 보관하고 있는 영역입니다.

## ****각 메모리 영역이 할당되는 시점은 언제인가요?****

- Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성
- Stack 영역 : 컴파일 타임 시 할당
- Heap 영역 : 런타임시 할당

## **생성자(Constructor)에 대해 설명해주세요.**

생성자는 클래스와 같은 이름을 가지는 메소드로, 객체가 생성될 때 호출되는 메소드입니다.

명시적으로 생성자를 선언하지 않는 경우에도, 내부적으로 매개변수가 존재하지 않는 기본 생성자가 자동으로 정의되며, 메서드 시그니처를 달리하여 생성자를 오버로딩할 수 있습니다.

## Wrapper 클래스와 boxing, unboxing에 대해 설명해주세요.

Wrapper 클래스는 원시 자료형에 대한 객체 표현입니다. 이러한 Wrapper 클래스는 Generic이나 Database의 ORM에서 사용됩니다.

Boxing은 원시 자료형을 Wrapper 클래스로 변환하는 것을 의미하며, Unboxing은 Wrapper 클래스에서 원시자료형으로 변환하는 것을 의미합니다. Jdk 1.5 버전 이상부터는 이러한 boxing과 unboxing을 명시적으로 수행하지 않아도 자동으로 수행해주는데, 이것을 auto boxing 및 unboxing이라고 부릅니다.
자바는 

## ****Synchronized에 대해 아는 대로 말해주세요.****

Synchronized는 멀티 스레딩 환경에서 공유 자원에 대한 동기화를 제공하기 위한 자바의 키워드 입니다. Synchronized 키워드는 메서드 레벨 동기화와 블록 레벨 동기화를 지원합니다. 

그리고 synchornized는 Thread의 동기화 순서를 보장해주지 않으며, synchronized 키워드를 남발하게 되면 프로그램의 성능 저하가 발생합니다.

- 정리
    
    [https://velog.io/@backtony/Java-synchronized-동기화#정리](https://velog.io/@backtony/Java-synchronized-%EB%8F%99%EA%B8%B0%ED%99%94#%EC%A0%95%EB%A6%AC)
    
    - synchronized method
        - 인스턴스 단위 lock
        - 동일한 인스턴스 내 synchronized 키워드가 적용된 메서드끼리 lock을 공유
    - synchronized block
        - this를 명시하면 synchronized method와 동일하게 동작하면서 synchronized method와 lock을 공유
        - 특정 객체를 명시하면 해당 객체에만 특정 lock을 걸면서 **해당 객체에 lock을 거는 block끼리만** lock을 공유
        - .class 형식 명시하면 해당 클래스에만 특정 lock을 걸면서 **해당 클래스에 lock을 거는 block끼리만** lock을 공유
    - static synchronized method
        - 클래스 단위 lock
        - static synchronized와 synchronized가 혼용되어있을 때 각자의 lock으로 관리
    - static synchronized block
        - 클래스 단위 lock
        - block의 인자로 정적 인스턴스나 클래스만 사용
    - **synchornized는 Thread의 동기화 순서를 보장하지 않는다.**

## ****new String()과 리터럴("")의 차이에 대해 설명해주세요.****

리터럴 방식으로 문자열 변수를 생성하면 Heap 영역의 문자열 상수 풀에 존재하는 문자열에 대한 레퍼런스를 변수에 저장하고, new 키워드 방식의 경우 새로운 객체를 Heap 영역에 생성하여 새로 생성된 객체에 대한 레퍼런스를 문자열 변수에 저장하게 됩니다.
동일한 문자열에 대해 new 키워드 방식으로 문자열 변수를 생성할 때, 각 변수들이 가지고 있는 참조 값은 다르지만, 리터럴 방식으로 문자열 변수를 생성한 경우 각 변수가 가지고 있는 레퍼런스의 값은 모두 동일합니다.

## ****String, StringBuffer, StringBuilder의 차이를 설명해주세요.****

String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 지닙니다.

StringBuffer는 내부적으로 synchronized 키워드를 사용하기 때문에 멀티 쓰레드 환경에서의 thread-safe를 보장하지만, StringBuilder는 동기화를 지원하지 않기 때문에 멀티쓰레드 환경에서는 부적합하고 주로 싱글 쓰레드 환경에서 사용됩니다.

StringBuilder는 동기화를 고려하지 않기 때문에 StringBuffer보다 성능이 우수하다는 특성이 있습니다.

## ****String 객체가 불변인 이유에 대해 아는대로 설명해주세요.****

Java의 설계단계에서 String을 불변으로 정한 정확한 이유는 모르지만, 다음과 같은 이점들을 고려하여 String 객체를 불변으로 정의했다고 생각합니다.

- String Pool을 통한 캐싱이 가능하므로써 메모리를 절약할 수 있고 성능을 향상시킬 수 있습니다.
- 또한, String 객체는 불변이기 때문에 thread-safe를 보장하여 멀티쓰레드 환경에서 적합합니다.
- 그리고 중요한 데이터를 String에 저장하는 경우에도, 불변성을 통해 데이터의 조작을 방지함으로써 얻는 보안상의 이점도 있다고 생각합니다.

## ****접근 제한자(Access Modifier)에 대해 설명해주세요.****

자바에서 접근 제한자는 클래스, 메서드, 필드에 객체가 접근할 수 있는 범위를 설정하는데 사용되는 개념입니다. 접근 제한자로는 public, default, protected, private이 있습니다.

public은 해당 요소와 같은 프로젝트 안의 누구든지 접근이 가능합니다

protected는 해당 패키지에서, 혹은 다른 패키지에서 상속 관계에 있는 요소들에서 접근이 가능합니다

private은 해당 요소 내에서만 접근이 가능합니다.

default는 해당 패키지 내에서만 접근이 가능합니다.

## ****클래스의 멤버 변수의 초기화 순서에 대해 설명해주세요.****

- 우선 클래스가 로드될 때 static 변수가 초기화됩니다.
- 이후 객체가 생성될 때, 필드 변수 선언부가 수행되어 초기화가 이루어지고, 생성자 블록이 실행되어 초기화가 이루어집니다.

## **static에 대해 설명해주세요.**

- static 키워드를 사용한 정적 변수나 정적 메소드는 클래스 로딩 시점에 메서드 영역에 로드되어 객체의 생성 없이도 접근이 가능합니다. 이러한 정적 변수 및 메서드는 모든 객체가 공유하여 사용하고, GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메서드 영역에서 유지됩니다.
- [static 변수와 static 메소드](https://dev-coco.tistory.com/23)

## **static을 사용하는 이유에 대해 설명해주세요.**

- static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있습니다.
- 인스턴스 생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용합니다.

## Inner 클래스의 장점

- 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.
- 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 증가시킬 수 있습니다.

## 리플렉션이란?

- 자바 가상 머신의 Method 영역에 있는 메타데이터를 가지고 런타임에 클래스 및 인터페이스를 검사하고 조작하는 기능입니다.
- 리플렉션을 통해 특정 필드에 접근할 때는, get으로 시작하는 메서드와 getDeclared 메서드를 통해 접근할 수 있습니다.
    - get으로 시작하는 메서드의 경우 해당 클래스와 상위 클래스의 public 요소들을 가져올 수 있고,
    - getDeclared로 시작하는 메서드를 통해 접근 제한자와 상관없이 해당 클래스의 모든 요소를 가져올 수 있습니다.
- private 멤버에 접근하려는 경우 .setAccessible(true) 를 호출이 필요합니다
- 코드 예시 : 기본
    
    ```java
    Class<MyClass> clazz = MyClass.class;
    
    // private 생성자 접근
    Constructor<MyClass> constructor 
    	= clazz.getDecalredConstructor(String.class, int.class);
    
    constructor.setAccessible(true);
    
    MyClass myclass = constructor.newInstance("헐크", 10);
    
    // private 필드 접근
    Field declaredFieldName = clazz.getDecalredField("name");
    declaredName.setAccessible(true);
    String name = (String) declaredName.get(myclass);
    
    // private 메서드 접근
    Method declaredPrint = clazz.getDeclaredMethod("print");
    declaredPrint.setAccessible(true);
    declaredMethod.invoke(myclass);
    
    // private final 필드 수정
    Field declaredId = clazz.getDecalredField("id");
    declaredId.setAccessible(true);
    declaredId.set(myclass, 5);
    ```
    
- 코드 예시 : 전략 패턴
    
    ```java
    public class Main {
    
    	public static void main(String[] args) throws Exception {
    		String strategyClassName = args[0];
    		final Class<?> clazz = Class.forName(strateguClassName);
    		final Constructor<?> constructor = clazz.getDecalredConstructor();
    		final MovingStrategy movingStrategy = (MovingStrategy) constructor.newInstance();
    		
    		movingStrategy.move();
    	}
    }
    
    ```
    
- 리플렉션의 장점
    - 동적 프로그래밍이 가능하여 구현체에 의존하지 않아도 되기 때문에 객체지향의 설계원칙인 의존성의 역전을 실천할 수 있다. 즉 이는 의존성을 외부에서 주입했기 때문에 가능하다.
- 리플렉션의 단점
    - 성능 저하
    - 코드 복잡도 증가
    - 보안 취약점

## 리플렉션은 어떤 경우에 사용하나요?

런타임 시점에 실행되고 있는 클래스에 대한 정보를 가져와서 실행해야 하는 경우에 사용합니다.

이러한 동적 바인딩 기능을 이용하여 IDE인 IntelliJ의 경우 자동 완성 기능을 제공하고, 스프링 프레임워크의 경우 어노테이션을 제공합니다.

## Error와 Exception의 차이점을 설명해주세요

- Error는 런타임에 발생할 수 있는 치명적인 오류를 의미합니다. Error는 컴파일 시점에 체크할 수 없으며, 에러가 발생하면 프로그램이 비정상적으로 종료됩니다.
- 반면, Exception은 Error보다 경미한 오류로, try-catch 구문을 이용해 프로그램의 비정상적인 종료를 막을 수 있습니다.
    - 예외에는 Checked Exception과 Unchecked Exception이 존재합니다.
        - Checked Exception은 컴파일 시점에 확인이 가능한 예외로, Checked Exception이 발생하는 메서드의 경우 try-catch문으로 예외를 직접 처리해주거나 throws로 예외를 전달해야만 합니다. 해당 예외를 처리하지 않은 경우 컴파일 시 에러가 발생합니다.
        대표적인 예시로는 *IOException*과 *SQLException*이 있습니다.
        - 반면, Unchecked Exception은 컴파일 시점에 확인이 불가능한 예외로, Checked 예외와 달리 예외에 대한 처리를 해주지 않아도 컴파일이 가능합니다.
        자바에서 Unchecked Exception은 전부 Runtime Exception에 속하며, 대표적인 예시로는 *NullPointerException과 ArrayIndexOutOfBoundException이 있습니다.*

---

## 익명 클래스란?

익명 클래스란 내부 클래스의 일종으로 이름이 없는 클래스입니다.

클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고, 오직 하나의 객체만을 생성할 수 있는 일회성 클래스 입니다.

재사용할 필요가 없는 일회성 클래스를 별도의 클래스로 생성하지 않아도 되기 때문에,  **코드를 줄이는 일종의 기법**

익명 클래스의 유의점으로는 오버라이딩 한 메소드만 사용이 가능하다는 점이 있습니다.

**인터페이스를 익명 객체로 선언**하여 사용할 수 있습니다.

## 람다란 무엇인가요?

- 람다 함수란 함수형 프로그래밍 언어에서 사용되는 개념으로 익명 함수 라고도 합니다.
    - Java8 부터 지원되는 기능으로, 코드의 생산성을 높이고 가독성을 향상시키는 것을 목적으로 두고 있습니다.
    - 이러한 람다함수는 메서드의 매개변수로 전달할 수 있고, 변수에 저장할 수 있습니다.
        - 이러한 방식을 통해 전달되는 매개변수에 따라 메서드의 행위가 결정될 수 있습니다.
- 람다를 도입함으로써
    - Java는 함수를 파라미터로 넘길 수 있고, 변수에 할당할 수 있으며, 반환 값으로 반환 할 수 있다.
    - 작성해야 하는 코드의 양이 줄어들면서 생산성이 증가한다
    - 코드의 재사용성이 높아진다
- 동작 파라미터화
    - 함수 혹은 코드 블록을 파라미터로 넘길 수 있도록 한 것
    - 장점 : 코드의 재사용성
- 람다의 형태
    - LambdaParameters → LambdaBody
    - 코드 예시
        
        ```java
        () -> 42;
        a -> a+1;
        (a, b) -> a + b;
        (a,b) -> {
        	...
        	return a + b;
        }
        ```
        
- 람다를 사용하기 위한 조건 : 함수형 인터페이스
    - @FunctionalInterface
    - 오직 한개의 추상 메서드를 가지는 인터페이스
    - 추상 메서드의 개수에만 제한이 존재하기 때문에, default 메서드나 static 메서드도 선언 가능
- 익명 클래스와의 차이점
    - 익명 클래스는 어떤 클래스 내부에서 사용할 뿐, 컴파일 되면 별도의 클래스 파일로 분리되어 나온다
    - 람다는 컴파일 시에도 별도의 클래스 파일로 분리되어 나오지 않는다
- 람다를 사용하면 안되는 경우
    - 내부에서 this를 사용하는 경우
    - 섀도우 변수를 사용하는 경우
    - 컨텍스트 오버로딩이 존재할 때

## 스트림은 무엇인가요?

- 스트림이란?
    
    스트림이란 컬렉션의 요소를 하나씩 참조해 람다식으로 처리할 수 있는 반복자입니다.
    
- 스트림의 구성
    - 컬렉션, 배열, 파일 등으로부터 스트림을 생성한다
    - 스트림을 대상으로 연산을 수행한다. 이러한 중간 연산자의 결과로는 새로운 스트림을 반환한다.
    - lazy evaluation : 최종 연산이 들어오기 전까지 중간 연산은 실제로 실행되지 않는다
        - 루프 퓨전
        - 쇼트 서킷
- 최종 연산자가 수행되면 스트림 파이프라인으 소비된 것으로 간주된다
- 장점
    - 가독성
    - 유연성 : 코드의 변경이 쉽다
    - 병렬처리를 간단하게 해결할 수 있다
        - parallel(), parallelStream() 키워드를 사용하여 가능
- 단점
    - 컴퓨팅 비용이 높다
    - 외부 변수들을 제어하기가 어렵다

---

## 객체 지향 프로그래밍에 대해 설명해주세요

- 객체 지향 프로그래밍은 소프트웨어 개발 패러다임 중 하나로, 현실세계의 개념과 객체를 모델링하여 이를 기반으로 소프트웨어를 설계하고 구현하는 방법론입니다.
- 객체 지향의 주요 특징으로 뽑히는 4대 특징으로는 캡슐화, 상속, 추상화, 다형성이 있습니다.
    - 캡슐화란 ~
    - 상속이란 ~
    - 추상화란 ~
    - 다형성이란 ~

## **제네릭에 대해 설명해주시고, 왜 쓰는지 알려주세요.**

- 제네릭이란 클래스나 메서드에서 사용할 내부 데이터 타입을 외부에서 지정하는 기법입니다.
- 제네릭 클래스는 클래스 선언에 타입 매개변수가 사용된 클래스입니다.
- 제네릭을 사용하는 이유는
    - 컴파일 타임에 타입을 체크함으로써 코드의 안정성을 높이는데 사용합니다
    - 반환값에 대한 타입 검사 및 변환에 들어가는 노력을 줄일 수 있기 때문에 생산성이 향상되고 가독성이 좋아집니다.
- 제네릭 메서드와 제네릭 클래스의 타입 매개변수가 같다면, 제네릭 메소드의 타입 매개변수가 우선시됩니다.
- 타입 매개변수
    - 타입 매개변수의 제한
        - 상한 경계
            - 타입 매개변수에 extends 키워드를 붙임으로써, 타입 매개변수를 특정 클래스 혹은 특정 클래스의 하위 클래스로 제한할 수 있습니다.
        - 하한 경계
            - 타입 매개변수에 super 키워드를 붙임으로써, 타입 매개변수를 특정 클래스 혹은 특정 클래스의 상위 클래스로 제한하는 방식입니다.
    - 와일드 카드
        - 비경계 와일드카드
            - 비경계 와일드카드는 ?를 사용하여 선언합니다. 비경계 와일드카드는 경계가 정해져있지 않기 때문에 어떤 타입이든 인자로 올 수 있습니다. 예를들어 비경계 와일드카드형 리스트가 있습니다.
            - 비경계 와일드카드형 리스트의 특징으로는, get() 메서드의 반환 타입은 Object이며, add() 메서드에는 null만 추가할 수 있다는 점입니다. 두 특징 모두 타입 매개변수로 어떤 타입이 올 지 모르는 것이 원인입니다.
        - 상한 경계 와일드 카드
            - <? extends T>
            - List의 get 결과는 T이다
            - add는 null만 가능
        - 하한 경계 와일드 카드
        - <? super T>
        - List의 get 결과는 Object
        - add는 T 혹은 T의 하위 클래스

---

## ****싱글톤 패턴에 대해 설명해주세요.****

## **직렬화(Serialize)에 대해 설명해주세요.**

---

## **추상 클래스와 인터페이스를 설명해주시고, 차이에 대해 설명해주세요.**

추상 클래스란 클래스 내에 추상 메서드가 포함될 수 있는 클래스로, 클래스 선언 시 abstract 키워드와 함께 선언됩니다. 

인터페이스는 추상 메서드와 정적 속성으로 구성되어있습니다.

추상 클래스와 인터페이스의 차이는 추상 클래스는 

인터페이스는 추상 클래스와 달리 

## ****Optional API에 대해 설명해주세요.****

---

## ****불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요.****

****💡 참조 타입일 경우 추가적인 작업은 어떤게 있는지 설명해주세요.****

****💡 불변 객체나 final을 굳이 사용해야 하는 이유가 있을까요?****

## **클래스와 객체에 대해 설명해주세요.**

클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용합니다.

객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다.

여기서 상태는 필드(fields), 행동은 메소드(Method)라고 표현합니다.

객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다.

## ****컬렉션 프레임워크에 대해 설명해주세요.****

## ****Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명해주세요.****

## ****Vector와 List의 차이를 설명해주세요.****

## ****final / finally / finalize 의 차이를 설명해주세요.****

## ****SerialVersionUID를 선언해야 하는 이유에 대해 설명해주세요.****
