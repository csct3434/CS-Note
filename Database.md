# 조인

- 조인 : 관계형 데이터 베이스에서 여러 테이블을 분산된 정보를 하나로 취합하여 조회하는데 사용하는 연산입니다
- **테이블을 하나의 컬럼으로만 구성하는 방식**
    - 장점 : 데이터를 하나의 테이블에서만 관리하므로 데이터의 정합성과 무결성을 유지하기 쉽습니다. 또한, 테이블이 정규화되어있고 크기가 작기 때문에 쿼리 최적화가 용이한 장점이 있습니다.
    - 단점 : 데이터를 검색할 때 여러 테이블간에 조인이 필요하므로, 성능 저하의 가능성이 있습니다. 그리고 스키마가 정규화되면서 복잡성이 증가하기 때문에, 쿼리 작성이 어려울 수 있습니다.
- **한 테이블에서 모든 컬럼을 관리하는 방식**
    - 장점 : 데이터를 검색할 때 조인 연산이 필요하지 않으므로, 조인 연산에 의해 발생하는 성능 저하를 방지할 수 있습니다. 또한, 여러 테이블 간에 조인이 필요하지 않으므로 쿼리 작성이 용이합니다.
    - 단점 : 중복 데이터가 발생할 가능성이 높아집니다. 중복 데이터가 증가하면 데이터의 정합성을 유지하기가 힘들며, 중복 데이터로 인한 저장 공간의 낭비가 발생합니다.
    - **데이터 무결성**
        - 데이터 무결성은 데이터의 값이 정확한 상태를 의미합니다.
        - 데이터 무결성이 훼손된 예시로는, 데이터 업데이트 과정에서 발생한 실수로 인해 사용자의 나이가 음의 값을 가지는 경우가 있습니다.
        - **데이터 무결성의 종류**
            - 엔티티 무결성
                - 기본 키 제약이라고도 하며, 모든 테이블은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야 한다는 조건입니다. 기본 키 제약 조건으로는 1) 기본키에는 null 값이 올 수 없으며 2) 테이블 내에서 기본키는 유일해야 한다는 점이 있습니다.
                - **기본키**란? 테이블 내에서 레코드를 식별하기 위해 후보 키 중에서 선택한 고유한 식별자 키
                - **후보키**란? 수퍼키 중 최소성을 만족하는 키들의 집합입니다.
                - 수퍼키란? 테이블의 모든 튜플을 유일하게 식별할 수 있는 속성들의 조합입니다.
            - 도메인 무결성
                - 테이블을 구성하는 필드의 무결성을 보장하기 위한 것입니다. 데이터 타입, null 값 허용 등에 대한 사항을 정의하고, 데이터가 입력된 경우 해당 사항들을 만족하는 지를 검사합니다.
                - 도메인 무결성이 훼손된 예시로는, 나이 필드에 문자가 입력된 경우가 있습니다.
            - 참조 무결성
    - **데이터 정합성**
        - 데이터 정합성은 분산된 데이터들 사이에 값이 일치하는 상태를 의미합니다. 비정규형을 사용하여 anomaly가 발생하면 데이터 정합성이 지켜지지 않습니다.
- **조인의 종류**
    - Cross Join
        - cartesian product라고도 하며, 두 테이블 간에 모든 행이 한번씩 조인되어 가능한 모든 경우의 수를 조합한 결과를 산출합니다.
    - Inner Join
    - Left Join
    - Right Join
- 참조 무결성 제약 조건
    - 외래키 컬럼의 값에 대한 제약 조건으로, 외래키 컬럼의 값은 참조 테이블의 Primary Key 값 혹은 NULL 값을 가져야 한다는 조건입니다.
- Cascade
    - 참조 테이블에서 레코드에 대한 변경 혹은 삭제 작업이 발생한 경우, 해당 레코드를 참조하는 외부 테이블의 레코드에서도 함께 변경 혹은 삭제가 발생하도록 지정하는 방식
    - 이를 통해, 데이터의 정합성을 보장할 수 있습니다.
- **인덱스**
    - 출처
        - https://hudi.blog/db-index-and-indexing-algorithms/
        - https://hudi.blog/db-clustered-and-non-clustered-index/
    - 인덱스란 추가적인 저장 공간을 사용하여 테이블의 탐색 속도를 향상시키기 위한 자료구조
    - 인덱스를 사용하지 않으면, **Full Table Scan**을 수행해야 하기 때문에 보조기억장치와 주기억장치 사이에 입출력 연산이 많이 발생하게 됩니다. 보조기억장치의 성능은 주기억장치에 비해 상당히 떨어지기 때문에, 데이터의 탐색 속도가 느려지게 됩니다.
        - Full Table Scan은 1) 테이블에 인덱스가 존재하지 않거나 2) 데이터베이스의 옵티마이저가 인덱스를 사용하지 않는 경우에 발생합니다.
    - 반면, 인덱스는 테이블에 비해 크기가 매우 작기 때문에 메모리에 한번에 로드하여 원하는 데이터의 물리적 저장 위치를 한번에 찾을 수 있습니다. 따라서, 보조기억장치의 접근횟수가 줄어들면서 데이터의 탐색 속도가 빨라지게 됩니다.
    - 데이터베이스에서 해시 테이블을 사용하지 않는 이유
        - 데이터의 탐색 속도는 빨라지지만, 데이터가 정렬되어 있지 않아 범위 탐색 시 Full Table Scan이 발생하기 때문입니다. 데이터베이스에서는 부등호 연산이 자주 발생하기 때문에, 데이터베이스에 해시 테이블은 적합하지 않습니다.
    - **B-Tree**
        - 이진 탐색 트리의 일반화된 형태로, 자식 노드가 2개 이상인 트리입니다.
        - B-Tree는 자식 노드의 개수를 늘리고 트리의 높이를 낮춤으로써 데이터의 탐색 속도를 개선한 것이 특징입니다.
        - 또한, B-Tree는 모든 리프노드가 같은 레벨에 위치한다는 특징이 있습니다. 이를 통해, 편향 트리의 문제점인 탐색 속도의 저하를 방지합니다.
        - B-Tree는 일반적인 이진 트리와 달리 한 노드에 여러 키를 가질 수 있습니다. 노드 내부의 키들은 항상 오름차순으로 정렬되어 있습니다.
            - B-Tree의 노드 : 페이지, 블록
            - 노드 내의 데이터 : 키
        - 노드의 각 키들은 좌측 포인터와 우측 포인터를 가지고 있는데, 좌측 포인터는 해당 키보다 작은 데이터를 가진 노드를, 우측 포인터는 해당 키보다 큰 데이터를 가진 노드를 가리킵니다.
        - 또한, 노드의 키는 데이터 포인터를 가지고 있는데, 이는 실제 데이터인 레코드가 저장된 물리적 위치를 가리키는 포인터입니다. 키를 기준으로 B-Tree를 탐색한 뒤, 일치하는 키를 발견하면 데이터 포인터를 이용하여 실제 레코드를 참조합니다.
        - B-Tree는 데이터의 탐색속도가 빠르다는 장점이 있지만, 트리가 항상 정렬된 상태를 유지해야 하기 때문에 데이터의 삽입, 변경, 삭제 연산의 성능이 좋지 않습니다.
    - **B+Tree**
        - B+Tree는 B-Tree를 개선한 자료구조입니다. 실제로 많은 DBMS에서 B-Tree대신 B+Tree를 사용합니다.
        - B+Tree와 B-Tree의 차이점
            - B+Tree는 리프 노드에서만 데이터 포인터를 가지고 있습니다.
            - ~~비단말 노드에서 데이터 포인터를 가지고 있지 않기 때문에, B-Tree에 비해 노드에서 더 많은 키를 보관할 수 있습니다. 이는 곧 트리의 높이가 낮아지는 것을 의미하기 때문에, 탐색 속도의 향상으로 이어집니다.~~
            - B+Tree의 리프노드는 B-Tree와 달리 서로 연결 리스트로 이어져 있습니다. 따라서, 순차 탐색 시 트리의 순회가 수반되는 B-Tree에 비해 순차 탐색의 성능이 좋다는 장점이 있습니다.
            - 반면, B+Tree의 단점으로는 트리에서 키의 중복이 발생한다는 점이 있습니다.
            - 또한, 데이터 접근 시 리프 노드까지 탐색해야 하기 때문에 고정적으로 O(logN)의 탐색시간을 가진다는 단점이 있습니다.
    - 인덱스 대상 컬럼을 선택할 때는 카디널리티가 높은 컬럼을 선택하는 것이 유리합니다.
    - 기본키와 외래키 컬럼에 대해서는 기본적으로 인덱스가 자동으로 생성됩니다
    - 인덱스가 있는 컬럼의 경우 O(logN)으로 탐색이 가능하고, 인덱스가 없는 경우 O(N)의 시간복잡도로 탐색이 이루어집니다.
    - 인덱스의 장단점
        - 장점
            - 검색 및 조인 시 성능이 향상됩니다
        - 단점
            - 인덱스를 비효율적으로 관리하는 경우 저장공간의 낭비가 발생할 수 있습니다.
                - 인덱스가 디비에서 차지하는 공간은 평균적으로 10%
            - 또한, 삽입, 수정, 삭제 연산 시 성능이 저하됩니다.
    
    ---
    
    # **논리적 쿼리의 실행 순서**
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/144cccb7-a804-4e5b-9fc9-78e579566607/58846b7a-ae7c-4254-8229-99bec2d74cd4/Untitled.png)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/144cccb7-a804-4e5b-9fc9-78e579566607/fa9f6620-9a13-41ff-a601-c58a96535e73/Untitled.png)
    
    입력: 테이블 T1, T2
    
    출력: 쿼리가 적용된 가상테이블 VT11
    
    1. FROM: 두 테이블의 카테시안 조인: T1 * T2 -> VT1
    2. ON: VT1에 대해 ON 절의 조건으로 필터링: VT1 >> VT2
    3. OUTER JOIN: 조인이 Inner Join이 아니었을 경우 VT2에 추가적으로 레코드를 삽입 VT2 + r -> VT3
    4. WHERE: VT3에 where 절의 필터가 적용됨 VT3 >> VT4
    5. GROUP BY: VT4의 레코드들을 group by에 의해 그룹핑 됨 VT4 -> VT5
    6. CUBE | ROLLUP: VT5에 CUBE 또는 ROLLUP에 의해 추가적인 정보 생성 VT5 + s -> VT6
    7. HAVING: VT6에 HAVING 조건에 의해 필터링 적용 VT6 >> VT7
    8. SELECT: VT7에 select에서 지정한 컬럼이 선택됨 VT7 => VT8
    9. DISTINCT: VT8의 레코드에서 중복을 제거함 VT8 > VT9
    10. ORDER BY: VT9르 order by에 지정된 컬럼으로 정렬 수행 VT9 -> VT10
    11. TOP: VC10에서 TOP에 의해 지정된 건수만큼의 레코드 선택 VT10 >> VT11
    
    요약 : FROM & JOIN → ON → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY → TOP
    
    ---
    
    # **인덱스 성능 실습**
    
    - 질문
        - 인덱스 생성 후 정렬 성능은 어떻게 변하는가?
        - 모든 필드들의 검색 성능은 동일한가? 인덱스를 설정한 필드에 대해서만 검색 성능이 개선되고, 그 이외의 필드에 대해서는 성능이 개선되지 않습니다.
        - 인덱스를 사용하면 무조건 성능이 개선되는가?  데이터베이스의 옵티마이저가 최적화 과정에서 해당 인덱스를 사용하지 않을 수도 있기 때문에 성능 개선이 항상 보장되지는 않습니다.
        - 오름차순 / 내림차순 정렬의 성능은 동일한가? 인덱스를 오름차순으로 설정한 경우, 오름차순 정렬이 내림차순 정렬보다 성능이 좋습니다. 하지만, 내림차순 정렬이 오름차순에 비해 성능이 떨어지긴 하지만 인덱스를 설정하지 않은 상태에서 내림차순을 정렬을 수행하는 것 보다는 빠릅니다.
        - **Cardinality** & **Selectivity**
            - Cardinality : 특정 데이터 집합의 유니크한 값의 개수입니다. 특정 컬럼의 카디널리티를 계산하는 방법은 ‘SELECT COUNT(DISTINCT 칼럼명) FROM 테이블’ 이러한 쿼리를 실행함으로써 특정 칼럼의 카디널리티를 계산할 수 있습니다.
            - Selectivity : Selectivity는 Cardinality를 전체 레코드 수로 나눈 값입니다. Selectivity가 높은 컬럼에 대해 인덱스를 설정하면, 필터링이 효율적으로 이루어지면서 검색 범위가 줄어들게 됩니다. 이러한 검색 범위의 축소는 검색 성능의 향상으로 이루어지기 때문에, Selectivity가 낮은 컬럼보다 높은 컬럼에 인덱스를 설정하는 것이 성능 향상에 유리합니다.

---

# **쿼리 튜닝 기초**

https://dev.mysql.com/doc/refman/8.0/en/using-explain.html

https://dev.mysql.com/doc/refman/8.0/en/optimizer-statistics.html

https://www.youtube.com/watch?v=TukZd6LjeBc

- explain 명령어는 데이터베이스의 옵티마이저가 선택한 쿼리 실행 계획을 확인하는 명령어입니다.

---

# **데이터 베이스의 물리적 저장구조**

- Page
    - 데이터베이스의 논리적 저장 단위
    - 레코드 혹은 컬럼의 값들이 페이지 안에서 나뉘어 저장됨
    - 파일 시스템의 Block과 유사
    - 크기 : 4KB, 16KB, 256KB 등
- I**nnoDB**
    - MySQL의 기본 데이터베이스 엔진
    - 페이지를 기반으로 하는 디스크 저장 방식
    - Row Store 방식
    - RID를 통해 레코드에 접근
    - 페이지 크기 16KB
    - B-Tree 기반 클러스터링 인덱스 지원 (MySQL에서는 innoDB와 TokuDB만 지원)
    - Secondary Index는 PK를 참조함
    - MVCC 지원
- 관계형 데이터베이스의 저장 단위
    - Row Store 방식 : 레코드 단위로 저장
    - Column Store 방식 : 컬럼 단위로 페이지에 저장
    - 일반적으로는 Row Store 방식을 사용
- Dense Index VS Sparse Index
- Index Full Scan VS Full Table scan

---

# 트랜잭션

- 트랜잭션이란
    - 트랜잭션이란 데이터베이스에서 수행되는 여러 작업을 하나로 묶은 논리적인 단위입니다.
- **ACID**
    - 이러한 트랜잭션이 안전하게 수행되는 것을 보장하기 위한 성질들이 있는데, 앞 글자를 따서 ACID 성질이라고 합니다.
    - A는 원자성으로, 트랜잭션이 완전히 수행되어 DB에 반영이 되거나, 혹은 중간 단계에서 실패한 경우 트랜잭션의 그 어떠한 실행 결과도 반영되지 않아야 하는 것을 의미합니다.
    - C는 일관성, 트랜잭션의 실행 결과가 데이터베이스의 데이터 무결성 제약 조건을 충족시켜야 한다는 점입니다. ( 일관된 상태를 보장해야 함을 의미합니다. ) 예시로, 트랜잭션이 데이터베이스에 존재하는 제약조건을 위배한다면 해당 트랜잭션은 취소됩니다.
    - I는 독립성으로: 한 트랜잭션에서 연산을 수행할 때, 다른 트랜잭션으로부터 영향을 받거나 영향을 주어서는 안된다는 것입니다. 즉, 각각의 트랜젹션의 수행이 독립적으로 이루어져야 한다는 성질입니다.
    - D는 지속성으로, 트랜잭션이 성공적으로 수행되면 그 실행 결과는 데이터베이스에 영구적으로 반영되어야 함을 의미합니다.
- **트랜잭션 격리 수준**
    - 여러 커넥션이 동시에 DB에 접근할 때, 해당 접근들을 제어하는 방법에 대한 설정입니다.
    - 트랜잭션 격리 수준으로는 READ-UNCOMMITED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE 4가지 격리 수준이 존재합니다. READ-UNCOMMITTED는 격리 수준이 낮아 동시성은 높지만 정합성이 떨어지고, SERIALIZABLE은 그 반대입니다.
    - **Read-uncommited** : 한 트랜잭션이 아직 commit되지 않은 상태에서 다른 트랜잭션이 해당 트랜잭션의 변경사항을 읽을 수 있습니다.
        - Dirty Read, Non-repeatable read, 팬 텀터리 문제 발생
    - **Read-committed** : read가 발생하는 시간을 기준으로 가장 최근에 commit된 데이터를 읽어오는 방식입니다.
        - 커밋이 완료된 데이터에 대해서만 읽기가 가능한 격리 수준입니다. 한 트랜잭션이 데이터를 변경했을 때 커밋하지 않은 상황에서, 다른 트랜잭션에서 해당 데이터를 읽어도 변경된 값이 아니라 변경되기 이전의 값을 읽게 됩니다.
        - Non-repeatable read, 팬텀 리드 문제 발생
    - **Repeatable-Read**
        - 트랜잭션이 실행되는 동안 트랜잭션의 시작 시간을 기준으로 가장 최근에 commit된 데이터를 읽는 방식입니다.
        - 팬텀 리드 발생
    - **Serializable**
        - 한 트랜잭션에서 사용하는 데이터를 다른 트랜잭션에서 접근할 수 없는 격리 수준입니다.
        - 트랜잭션의 ACID 성질이 엄격하게 지켜지지만, 동시성이 낮기 때문에 성능은 가장 떨어집니다.
    - 트랜잭션에서 발생할 수 있는 문제
        - Dirty Read
            - 한 트랜잭션에서 데이터를 변경하고 롤백을 수행하는 그 시간 사이에, 다른 트랜잭션이 해당 데이터를 읽게되어 해당 트랜잭션의 실행 결과가 유효하지 않은 문제 상황을 의미합니다.
        - Non-repeatable Read
            - 한 트랜잭션에서 동일한 데이터에 대한 조회 연산을 여러 번 수행했을 때, 각 조회 결과가 일치하지 않는 데이터 불일치 문제입니다.
        - Phantom Read
            - **한 트랜잭션 안에서 일정범위의 레코드를 두번 이상 읽을 때, 첫 번재 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나거나, 첫 번째 쿼리에 있던 레코드가 두번째 쿼리에서 사라지는 현상을 의미합니다.**
- 트랜잭션의 처리 과정
    - 
- **CAP** 이론
    - https://onduway.tistory.com/106
    - http://eincs.com/2013/07/misleading-and-truth-of-cap-theorem/
    - Consistency, Availability, Partition Tolerance 세 가지 속성을 모두 만족시키는 분산 시스템을 구성하는 것은 불가능하다는 이론입니다.
    - 즉, 분산 데이터베이스 시스템 내에 분할이 발생한 경우, 가용성과 일관성 둘 중 하나는 희생해야 한다는 것을 의미합니다.
    - 분산 데이터베이스 시스템은 네트워크 장애나 서버 장애 등의 이유로 Partition이 발생할 수 밖에 없기 때문에, Partition Tolerance는 보장되어야 합니다.
    - Consistency
        - Consistency란 사용자가 분산 데이터베이스 상에서 어떤 노드와 통신을 하던지 상관없이 같은 데이터를 조회할 수 있는 성질을 의미합니다. 시스템이 모든 인스턴스에 변경 사항을 즉시 적용하는 것은 실질적으로 불가능하기 때문에, 일관성의 목표는 데이터의 동기화를 빠른 시간내에 처리하여 사용상에 문제가 없도록 하는 것입니다.
    - Availability
        - 가용성이란 시스템이 제공하는 서비스는 중단되지 않고 언제든지 사용 가능해야 한다는 성질입니다. 가용성은 사용자가 데이터가 일관되지 않더라도 언제든지 접근할 수 있다는 것을 의미한다.
    - Partition Tolerance
        - Partition Tolerance란 시스템 내에 분할이 발생했을 때 시스템이 여전히 작동하는 것을 의미합니다.
    - 많은 NoSQL은 일관성을 포기함
- ****NoSQL의 특성 : BASE****
    - Basically Available
    - Soft State
    - Eventual Consistency
    - 산 vs 염기?
- ****트랜잭션과 Serial Schedule****
    - 가장 쉽게 ACID를 지원하는 방법은?
        - 한 번에 하나씩의 트랜잭션만 실행
- ****Serial Schedule****
    - 세 트랜잭션 A, B, C가 있을 때 한 번에 하나씩 실행했을 때 가능한 결과들의 집합 : 3!
- ****Serializable****
    - 실제 데이터베이스의 트랜잭션 결과가 Serial Schedule의 부분집합인 경우 Serializable이라고 함
- Optimistic Lock VS Pessimistic Lock
- ****Transaction에서 발생할 수 있는 문제들****
- Lock
    - 데이터베이스의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장할 수 있는 직렬화 장치
    - 즉, 여러 개의 트랜잭션이 데이터에 동시에 접근했을 때, 데이터의 일관성을 보장하기 위해 잠금을 건다
    - Lock의 종류
        - Optimistic Lock
            - 대부분의 트랜잭션에서 데이터 충돌이 발생하지 않을 것이라는 낙관적 관점 하에, 데이터베이스의 락 기능을 사용하지 않고, 애플리케이션 수준에서 버전관리를 통해 동시성을 제어하는 방식입니다.
            - 데이터를 처음 가져올 때 버전을 확인하고, 데이터를 갱신하기 전에 다시 버전을 확인했을 대 버전이 같다면 commit을 진행하고, 버전이 다르다면 rollback 시키는 방식입니다.
            - 장점 : 데드락 가능성이 적으며, 성능상의 이점이 있습니다
            - 단점 : 충돌이 발생하면 이를 해결하는데 오버헤드가 발생합니다.
        - Pessimistic Lock
            - 대부분의 트랜잭션에서 데이터 충돌이 발생한다는 관점 하에, 데이터베이스의 락을 사용하여 동시성을 제어하는 방식입니다.
            - 데이터베이스에 실제 락이 걸리기 때문에, 무결성이 보장된다는 장점이 있지만 데드락의 위험성이 존재합니다.
            - 비관적 락의 종류
                - Shared Lock
                    - 한 트랜잭션이 락을 획득하여 데이터를 사용중인 동안, 다른 트랜잭션이 해당 데이터를 읽을 수는 있지만 갱신은 불가능한 방식입니다.
                    - S Lock은 ㅇ
                - Exclusive Lock : 한 트랜잭션이 락을 획득하여 데이터를 사용중인 동안에, 다른 트랜잭션은 데이터에 아예 접근할 수 없는 방식입니다.
            - 장점 : 충돌에 대한 오버헤드가 줄어들고, 무결성을 유지에 도움이 됩니다.
            - 단점 : 충돌이 발생하지 않는 경우 락의 획득과 해제에 오버헤드가 발생합니다.
        - 긍정적 락은 충돌이 적게 발생하거나 읽기 작업이 많이 발생하는 경우, 비관적 락은 충돌이 많이 발생하거나 수정작업이 많이 발생하는 경우
    
    ---
    

**반정규화**??

---

루트페이지와 브랜치페이지는 자식페이지에 대한 정보를 가지고 있습니다

INSERT : 페이지가 가득 찰 경우 페이지 분할이 발생한다

DELETE : 인덱스의 데이터가 실제로 지워지지 않고 사용 안함 표시를 합니다

UPDATE : 실제 데이터를 갱신시키는 것이 아닌, 기존의 데이터를 DELETE하고 새로운 데이터를 인덱스에 추가합니다.

update와 delete의 경우 where절이 적용되면 탐색성능은 빨라지지만, 사용하지 않는 인덱스가 적용되었다면 불필요한 처리량이 증가하고 사용하지 않는 데이터가 늘어남에 따라 페이지 낭비와 인덱스 조각화가 심해진다

---

## 인덱스 종류

클러스터링 인덱스

- 인덱스의 리프 페이지가 데이터 페이지로 구성된 인덱스입니다.
- 데이터 페이지는 특정 컬럼을 기준으로 정렬된 상태를 유지합니다.
- 클러스터링 인덱스는 테이블 당 1개만 존재합니다.
- 클러스터링 인덱스는 Primary Key를 설정하거나, NOT NULL과 UNIQUE 제약조건을 함께 설정하는 경우 생성됩니다.
- 만약 Primary Key와 NOT NULL 및 UNIQUE 제약조건이 함께 설정된다면, Primary Key가 우선순위를 갖습니다.
- 클러스터링 인덱스의 키는 데이터이고, 밸류는 데이터 페이지의 주소를 의미합니다.

논클러스터링 인덱스

- 인덱스 페이지와 데이터 페이지가 분리되어 있는 인덱스를 의미합니다.
- 클러스터링 인덱스 방식과 달리 데이터 페이지가 정렬된 상태를 유지하지 않습니다.
- 논클러스터링 인덱스는 인덱스를 직접 설정하거나, UNIQUE 제약조건을 설정함으로써 생성됩니다.
- 인덱스를 생성할때는 UNIQUE 인덱스와 디폴트 인덱스가 존재하는데, UNIQUE 인덱스는 중복을 허용하지 않는 인덱스를 생성하고, 디폴트 인덱스는 중복을 허용하는 인덱스를 생성합니다.
- 논 클러스터링 인덱스의 키는 데이터를 의미하고, 밸류는 RID, 즉 페이지 번호와 오프셋를 의미합니다.
- **클러스터링 인덱스보다 갱신 작업이 빠르다**
    - 데이터 페이지의 정렬이 발생하지 않기 때문에
- **클러스터링 인덱스보다 범위 탐색 성능이 안좋다**
    - 데이터페이지가 정렬되어 있지 않기 때문에 여러 페이지를 로드하기 때문에 느리다

클러스터링 인덱스 + 논클러스터링 인덱스

- 세컨더리 인덱스는 클러스터링 인덱스의 키값을 참조합니다.
- 세컨더리 인덱스를 탐색하여 찾은 값을 바탕으로, 클러스터링 인덱스를 한번 더 탐색하므로써 데이터 페이지에 접근하게 됩니다.
- 이러한 방식을 사용하는 이유는, 논클러스터링 인덱스에서 데이터 페이지 주소에 대한 정보를 가지고 있을 경우, 데이터 페이지에서 변경사항이 발생할 때 마다 모든 논클러스터링 인덱스에서도 갱신작업이 발생합니다. 하지만, 논클러스터링 인덱스에서 클러스터링 인덱스의 키값을 참조하는 경우, 데이터가 다른 페이지로 이동하거나, 페이지 내에서 데이터의 순서가 뒤바뀌어도 논클러스터링 인덱스에서는 테이블 재구성이 발생하지 않습니다. 이처럼, 논클러스터링 인덱스에서 테이블 재구성에 따른 오버헤드가 적기 때문에 논클러스터링 인덱스에서는 클러스터링 인덱스의 키값을 참조합니다.
- 논 클러스터드 인덱스만 사용하는 방식에 비해서 성능이 좋지 않습니다
    - 클러스터링 인덱스를 추가적으로 탐색해야하기 때문에
- 논 클러스터드 인덱스와 클러스터드 인덱스를 삭제해야 되는 경우, 논 클러스터드 인덱스를 먼저 삭제하는 것이 효율적이다
    - 클러스터드 인덱스를 먼저 삭제하면 논 클러스터드 인덱스에서 클러스터드 인덱스의 키 대신 데이터페이지의 주소 정보로 대체해야 하기 때문에 추가적인 부하가 발생하기 때문입니다.

## 인덱스를 효율적으로 적용하는 방법

- 카디널리티가 높은 컬럼에 대해 인덱스를 설정하는 방
- WHERE, ON, HAVING, ORDER BY와 같은 조건절에 자주 사용되는 컬럼에 인덱스를 적용
- 규모가 큰 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- WHERE 절에서 인덱스가 설정된 컬럼에 연산을 수행한다면 인덱스가 적용되지 않는다
- 일반적으로 웹 서비스에서 R과 CUD의 비율이 8:2 혹은 9:1 정도로  알고있습니다
- 풀테이블 스캔을 하는 경우
    - 테이블에 인덱스가 없는 경우
    - 테이블의 규모가 작거나 인덱스로 필터링 한 결과가 약 전체 데이터의 20~25%를 넘어가는 경우
- 복합 인덱스
    - 다중 컬럼 인덱스, composite index, 결합 인덱스
    - 두 개 이상의 컬럼을 기준으로 생성한 인덱스
    - 하나의 컬럼으로 인덱스를 구성하는 방식보다 두 개 이상의 클럼에 대해 설정한 인덱스가 카디널리티가 높기 때문에 탐색 성능이 더 좋습니다
    - 인덱스를 생성할 때 명시한 컬럼의 순서에 따라 인덱스의 구조가 달라집니다. 인덱스의 첫번째 컬럼이 아닌, 두번째나 세번째 컬럼에 대해서만 조건절을 적용한 경우 풀테이블 스캔을 수행하게 됩니다.
- EXPLAIN 컬럼의
    - 쿼리의 실행 계획에서 성능과 관련된 중요한 내용이 표시
    - USING INDEX
    - USING WHERE : InnoDB 스토리지 엔진을 통해 테이블에서 행을 가져온 후, MySQL 엔진에서 추가적인 체크 조건을 활용하여 행의 범위를 축소한 것
    - USING FILE
    - USING INDEX CONDITION : 인덱스 컨디션  푸시다운을 의미합니다. 인덱스 컨디션 푸시다운은 ??
- 인덱스의 실행 계획
    - ALL : 테이블 전체를 스캔하는 풀테이블 스캔
    - RANGE : 인덱스 레인지 스캔, 인덱스를 이용하여 범위탐색
        - 이상적으로 인덱스를 잘 설정한 경우에 발생하는 실행 계획
    - INDEX : 인덱스를 전체 스캔

완전 함수 종속이란 기본키의 일부가 아닌 전체에 의해서만 종속되는 관계를 말합니다. [예를 들어, **학번과 과목번호 → 성적**은 완전 함수 종속입니다1](https://velog.io/@busybean3/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%95%A8%EC%88%98-%EC%A2%85%EC%86%8D%EC%84%B1Functional-Dependency)[2](https://valuefactory.tistory.com/222).

부분 함수 종속이란 기본키의 일부에 의해서만 종속되는 관계를 말합니다. [예를 들어, **사원번호 → 사원이름**은 부분 함수 종속입니다1](https://velog.io/@busybean3/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%95%A8%EC%88%98-%EC%A2%85%EC%86%8D%EC%84%B1Functional-Dependency)[2](https://valuefactory.tistory.com/222).

이행적 함수 종속이란 A → B, B → C와 같이 간접적인 관계로 인해 발생하는 함수 종속을 말합니다. [예를 들어, **학번 → 학과이름, 학과이름 → 학과전화번호**는 이행적 함수 종속입니다1](https://velog.io/@busybean3/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%95%A8%EC%88%98-%EC%A2%85%EC%86%8D%EC%84%B1Functional-Dependency)[2](https://valuefactory.tistory.com/222).

커버링 인덱스 : 쿼리를 충족하는데 필요한 모든 데이터를 갖는 인덱스를 뜻한다.

---

## DBMS와 Database의 차이점

- DB는 데이터를 저장하는 장소입니다
- DBMS는 데이터베이스를 운영하고 관리하는 소프트웨어입니다.

## 스토어드 프로시저?

- 일련의 쿼리를 모아서 마치 하나의 함수처럼 실행하기 위한 쿼리들의 집합입니다.
    - 하나의 요청으로 여러 SQL문을 실행할 수 있어 네트워크에 대한 부하를 줄입니다,
    - 하지만, 재사용성이 나쁘기 때문에 실무에서는 거의 안쓰는 편입니다.
- `DELIMITER` 를 프로시저 앞 뒤에 위치합니다.
- `PROCEDURE` 를 CREATE합니다
- `BEGIN` , `END` 안에 프로시저의 실행 내용에 대해서 정의합니다.

## 커버링 인덱스란?

- 쿼리를 충족하는데 필요한 모든 데이터를 가지는 인덱스를 말합니다.
    - `select, where, order by, limit, group by` 등에서 사용하는 모든 컬럼이 Index컬럼 안에 다 포함되는 경우
    - 실제로 `select` 절까지 모두하면, 너무 많이 쓰므로, Select를 제외한 나머지 부분만 우선으로 실행
    - 그래서 View table에 id값만 가져옴 그래서 Join함

### 꼬리 1 - 커버링 인덱스가 빠른이유

- 사실 성능저하는 인덱스를 통해서 잘찾는데 나머지 row의 컬럼값을 데이터에서 읽어올때 큰 성능저하가 발생함
    - 페이징 쿼리와 무관하게 인덱스를 타도 느린것은 SELECT에 있는 데이터를 읽기위해서입니다.
- 미리 사용한 클러스터링 인덱스에 대해서 가져왔기 때문에 나머지 row를 읽는데 시간이 덜걸려서 빨라짐

### 꼬리 2 - 커버링 인덱스의 단점

- 커버링인덱스는 너무 많은 인덱스가 필요해짐
    - 쿼리의 SELECT 빼고 모든 항목이 index에 포함되어야하기 때문
- Index의 크기가 너무 커짐
    - order by, group by, having에 들어간 컬럼들까지 인덱스에 들어가야하므로 너무 크기가 커짐
- 데이터 양이 많아지면, NoOffset방식에 비해 느림
    - 테이블 사이즈가 커진다면, 느려짐

### 꼬리 3 - Index는 언제 설정해야할까요?

- 인덱스는 Where절에서 효과가 있습니다.
    - 그냥 FROM 에서만 사용할때는 효과를 보지 못함
- Cardinality가 높을 수록 인덱스 설정에 좋습니다.
    - 카디널리티는 특정 데이터 집한의 유니크한 값을 개수를 의미합니다.
- 선택도가 낮을 수록 인덱스 설정에 좋습니다.
- 활용도가 높을 수록 인덱스 설정에 좋습니다.
- 중복도가 적을수록 인덱스 설정에 좋습니다.

### 꼬리 4 - NoOffset방식은?

- 조회 시작 부분을 인덱스로 빠르게 찾아서 매번 첫 페이지만 읽도록 하는 방식입니다.
    - limit과 offset에 대해서 합친만큼을 다 안읽어도 됩니다.
- 쓰기전에 Index를 꼭 사용해야합니다. → Cusor방식으로도 불립니다.

### 역색인이란?

## webp의 특징?

- 구글에서 만든 이미지 포맷
- 장점
    - 다른 이미지 포맷에 비해 크기가 작다는 장점이 있습니다
    - GIF 방식에 비해 더 많은 색 표현이 가능하다
    - 구글에서 로열티를 요구하지 않기 때문에 무료
- 단점
    - 아직 모든 브라우저에서 지원하지 않는다는 점이 있습니다
        - IE와 iOS 13 이하 버전에서는 webp 이미지를 지원하지 않습니다
    - 애니메이션 이미지의 경우 gif보다 cpu 사용량이 더 높습니다

---

스토어드 프로시저

- 일련의 쿼리들을 마치 하나의 함수처럼 실행할 수 있는 쿼리들의 집합
- 장점
    - 한번의 요청으로 여러 쿼리를 실행할 수 있기 때문에 네트워크 오버헤드가 적게 발생합니다
    - 쿼리문이 노출되지 않기 때문에 보안상의 이점도 있습니다
- 단점
    - 처리 성능이 좋지 않습니다
    - 재사용성이 좋지 않습니다

스토어드 함수

- 데이터베이스에서 사용자가 직접 만들어서 사용하는 함수

---

## MVCC란?

- 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위한 방법중 하나임
- 하나의 레코드에 여러 버전이 관리된다는 의미입니다.
    - 잠금을 사용하지 않는 일관된 읽기로 LOCK방식보다 훨씬 빠릅니다.
- MYSQL에서는 다음과 같이 동작하빈다
    - 데이터를 변경할때마다 변경사항을 UNDO영역에 저장합니다.
    - 한 레코드에 여러 변경사항이 있다면, 이전의 데이터를 덮어씌우지 않고 새로운 버전의 데이터를 UNDO에 생성합니다.
    - 사용자는 마지막 버전의 데이터를 보통 읽는다
    
    ### 꼬리 1 - UNDO 영역이란?
    
    - UPDATE나 DELETE 문장으로 데이터를 변경했을때 변경되기 전의 데이터를 보관하는 곳
        - 롤백을 대비하거나, 트랜잭션의 격리수준을 유지하면서 높은 동시성을 제공하기 위해 사용
    
    ### 꼬리 2 - Insert Buffer란?
    
    - RDBMS는 insert, update될때, 데이터 파일을 변경하는 작업도하지만 인덱스도 B+ 트리에 작업을 해야합니다
        - 인덱스 업데이트는 랜덤하게 디스크를 읽어야하기 때문에, 너무 많은 자원을 사용함
        - 이를 방지하기 위해서, 업데이트를 즉시 실행안하고 임시공간에 저장하고, 사용자에게 결과를 반환하는 형태로 성능을 향상시킴 → 이때의 공간이 Insert Buffer임
    
    ### 꼬리 3 - REDO
    
    - 리두 로그는 ACID를 보장하기 위해서 변경된 내용을 순차적으로 디스크에 기록하는 로그파일입니다.

- MVCC란
    
    데이터베이스에서 레코드에 대한 여러 버전을 관리함으로써 동시성을 제어하는 방법입니다.
    
    mvcc는 데이터를 읽을 때 격리 수준에 따라 특정 시점을 기준으로 가장 최근에 commit된 데이터를 읽는 방식입니다
    
    mvcc는 write 연산이 발생할 때 마다 이력을 관리합니다
    
    mvcc에서는 read와 write연산이 서로를 blcoking 하지 않기 때문에 lock 기반 동시성 제어 방식보다 동시성과 처리량이 우수합니다
    
    mvcc의 특징으로는 커밋된 데이터에 대해서만 읽기가 가능하기 때문에 읽기 일관성이 보장된다는 장점이 있습니다.
    
    locking read란 읽기 연산을 수행하면서 write 락을 취득하는 방법을 의미합니다. 쿼리문을 작성할 때 select 절에 for update를 붙임으로써 locking read를 수행합니다.
    
    mysql에서는 locking read를 수행하면 격리 수준과 상관엇이 read 를 수행한 시점을 기준으로 가장 최근에 커밋된 데이터를 읽게됩니다
    
    locking read에는 for update 방식과 for shared 방식이 있습니다.
    
    mysql에서는 write skew를 해결하기 위해 locking read를 사용한다
    
    mysql에서 consistent read란?
